# JS 210429 - 기초 실습



## 오전

- Node.appendChild() 에서 만약 주어진 노드가 이미 문서에 존재하는 다른 노드를 참조한다면 새로운 위치로 이동 -> 무슨 의미인지 질문
  - 기존 부모 위치에서 새로운 부모의 위치로 이동한다는 뜻
- append() 의 DOMString이나 Node 객체를 여러 개 넣을 수 있다?
  - DOMString - 자바스크립트에서 사용하는 문자열



- 홈워크, 워크샵 복습
  - function () 부분에 (event)를 쓰고 안 쓰고는 무슨 차이인가요..?
    - event 객체를 적지 않으면 event 객체를 활용할 수 없다 (preventDefault, 해당 이벤트 대상에서 값 가져오기 등)
  - action='#' 같은거 쓰면 안되나요? 
    - html 문서내에 특정 키워드(헤더)로 보낼 때 #을 사용하므로 비추
    - https://developer.mozilla.org/ko/docs/Web/API/EventTarget#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80_%ED%98%B8%ED%99%98%EC%84%B1



- 기능 추가 연습해보기

  - li 삭제 버튼 누르면 해당 리스트 아이템 삭제

  ```js
          // 새로운 button 요소를 만든 뒤
          const todoLiBtn = document.createElement('button') // <button></button>
          todoLiBtn.innerText = 'X'
  
          // 클릭하면 li 요소를 삭제하는 이벤트 처리기를 붙인다.
          todoLiBtn.addEventListener('click', function () {
            todoLi.remove()
          })
          // li 요소에 삽입한다.
          todoLi.append(todoLiBtn)
  
          // ul 요소에 삽입한다.
          const todoUl = document.querySelector("#todo_ul")
          todoUl.append(todoLi)
  ```

  

  - 해당 li의 텍스트 부분을 누르면 클래스를 생성, 클래스가 이미 생성되어있으면 제거

  ```javascript
          // 클릭했을 때 클래스 체크 여부 파악 후 .done 클래스 추가 제거
          // https://developer.mozilla.org/ko/docs/Web/API/Element/classList
          todoLi.addEventListener('click', function(event) {
            // todoLi.className 클래스가 1개면 이걸로도 가능
            // if (todoLi.classList.contains('done')) {
            //   // todoLi.removeAttribute('class') // 문제점 전체 클래스가 날아감
            //   todoLi.classList.remove('done')
            // }
            // else {
            //   // todoLi.setAttribute('class', 'done') - 문제점 기존에 존재하던 클래스 다 날아가고 여기서 적힌 클래스만 적용됨
            //   todoLi.classList.add('done') // 기존 클래스에서 하나 더 추가
            // }
            // 위의 기능을 이거 하나로 구현 가능
            todoLi.classList.toggle('done')
          })
          // 그래서 attribute는 요소가 1개로 끝날 수 있는 태그들 (method, id 이런거)에 사용을 권장
  ```

  - classname으로 접근하는거랑 classlist로 접근하는거랑 차이
    - classname 은 string을 반환 - 그래서 정확하지 않을 경우도 있음(특정 문자열만 존재하면 통과)
  - classList로 접근해서 remove랑 add하는거랑 Attribute로 접근하는 것의 차이
    - classList - 기존 클래스에서 해당 클래스를 추가, 삭제
    - setAttribute - 기존에 존재하던거 싹 다 날리고 해당 요소 안에 있는 것으로 바꿈
    - attribute는 요소가 1개로 끝날 수 있는 태그들 (method, id 이런거)에 사용을 권장 (사용 할거면)

  - event.target 부분이 전체선택같은건가요?
    - 위의 코드에서는 event.target == form, 즉 해당하는 이벤트의 대상을 의미함(값이 바뀌거나 무언가가 실행될 대상)

  

- 어제 배웠던 내용 다시 한번 언급
  - 바닐라 자바스크립트, 브라우저 기능, dom 선택 조작, 이벤트 





- vue.js, react 와 같은 라이브러리를 통해 DOM 조작을 간소화 시킬 수 있음.





### ECMASrcipts 6

- 줄여서 es
- ECMA에서 제정한 표준화된 자바스크립트
- 세미콜론 있어도되고 없어도됨 - 자동으로 세미콜론 추가해줌(스크립트에서)
- 스타일 가이드에 맞춰서 자동으로 정리해주는 추가 기능도 있음 - 그래도 우리가 제대로 작성할 줄은 알아야함
  - airbnb style, standardjs, google style이 대표적
  - airbnb 가 가장 유명
  - airbnb 스타일 가이드를 중심으로 진행하되 세미콜론은 사용 하지 않고 진행





### 변수와 식별자



#### 식별자

- 변수 이름을 어떻게 지을지
- js는 카멜케이스 사용 - articleId (장고는 스네이크 케이스 article_id)
- _나 $로 시작하는 변수에 암묵적인 의미가 있나요
  - _는 python과 같이 for문을 사용할 때 해당하는 i, j 등을 사용하지 않을 때 _로 적기도 하고
  - lodash를 사용할 때 _ 로 변수를 불러오는 경우가 많다.
  - 과거 jquery에서 객체가 $ 표시로 사용했었음
  - 결론 - 정확히 무슨 의미가 있는 건 아니지만 특정 라이브러리나 기능에 따라 특정 의미로 사용되는 경우가 있다.



- 카멜 케이스(camelCase, lower-camel-case) - 변수, 객체, 함수

```js
// 숫자, 문자, 불리안
let dog
let variableName

// 배열 - 배열은 복수형 이름을 사용
const dogs = []
const dogList = []

// 정규 표현식 - 정규 표현식은 'r'로 시작
const rDesc = /.*/

// 함수
function getProperty () {}

// 이벤트 핸들러 - 변수 명이'on' 으로 시작하는 경우가 많음
function onClick () {}
function onKeyDown () {}

// 불리언 반환
let isAvailable = false
```

- 파스칼 케이스 (PascalCase, upper-camel-case) - 클래스, 생성자

```js
class User {
    constructor (options) {
        this.name = options.name
    }
}
const user1 = new User ({ name: '홍길동' })
```

- 대문자 스네이크 케이스 (SNAKE_CASE) - 상수
  - 대문자 표현은 변수와 변수의 속성이 변하지 않는 것을 암묵적으로 표현한다. (읽기 전용)

```js
const API_KEY = 'SOME KEY'
const PI = Math.PI

// 상수가 아닌 경우
const numbers = []
numbers = 'abc' // X 즉 변수 자체에 값이 할당이 되지 않는 것이지 값이 변하지 않는 것은 아님
```



#### 변수

- pdf 예시를 보면서 넘어가기?
- ES5 까지는 var 사용했었으나 var는 선언되지 않음에도 참조가 가능한 문제가 있었음 + 재선언도 가능했음(위에 읽고 밑에 선언해도 위에서 읽음) -> 개선을 위해 let, const 가 나옴
- let, const의 차이점
  - let - 재할당 할 수 있는 변수 선언 시 사용, 변수 재선언 불가능, 블록 스코프
  - const - 재할당 할 수 없는 변수 선언 시 사용, 변수 재선언 불가능, 블록 스코프
  - 블록 스코프 - {} 범위 에서만 살아있음