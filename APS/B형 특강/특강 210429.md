# 특강 210429



### disk scheduling

- api 설명을 참조하여 각 함수를 구현



- 접근하기 위한 방법
- 알아야할 개념 
  - 어떤 트랙들이 입력으로 들어와 있는지
  - 각각의 스케쥴링이 들어왔을 때 다음 스케쥴 선택하는 것
- 가장 접근하기 쉬운 방법 - 브루트포스
  - 들어온 순서대로 queue에 저장
    - fcfs는 queue에서 순서대로 빼는 것으로 처리
    - 더 단순하게는 차례대로 가장 빠른 것을 확인하는 것으로 처리
  - sstf, look, c-look 은 전체 데이터 중 해당 데이터를 찾아서 처리
  - 풀 수는 있지만 시간이 너무 오래걸린다.
- 배열을 좀 더 활용해서 접근해보자
  - 들어온 순서대로 queue에 저장
  - 배열을 이용하여 현재 디스크 상태를 표시
    - sstf, look, c-look 은 head 와 인접한 디스크만 찾아서 처리
  - 이래도 여전히 조금 시간이 걸림
- 연결 리스트 방식으로 바꿔보자 (배열에서)
  - 삽입 삭제에 조금 더 시간이 걸림
- 연결 리스트를 확장시킴
  - 숫자의 범위에 따라 표지를 달아놓음 (0~19 페이지 내에는 14가 들어가고, 20~39 페이지 내에는 37을 들어가고, 각 디스크 숫자마다 레이블을 달아줌)
- 조금 더 단순하게 변형하면
  - 각 레이블 마다 순서대로 해당하는 레이블의 값들을 넣어놓음 (전체 연결리스트로 사용하지 않고)
- 조금 더 단순하게 2
  - 정렬을 하지 않고 큰 범위의 레이블에 그냥 때려넣음 (0~99)- 나중에 찾을 때 시간이 걸림
- 자료구조는 삽입,삭제와 탐색 시간 사이에서 서로 교환 (삽입,삭제가 빨라지면 탐색이 느려짐) - 그래서 이 문제에서 적절한 방법을 찾는것이 핵심
- 위의 연결리스트 처럼 되있는 것을 배열의 형태로 저장해서 진행해도 큰 차이는 없으므로 배열이 더 익숙하면 배열로
- 여기까지 단순하면서도 어느정도 효율적으로 풀 수 있는 방법



- 복잡한 자료구조 지만 좀 더 효율적으로 풀 수 있는 방법
- priority queue (heap)
  - 개념 다시 복습
  - pq를 이용하여 head 값을 기준으로 작은 값은 max heap에 넣고, 큰 값은 min heap에 넣으면 head보다 작은 값과 큰 값 중 가장 가까운 값이 각 heap의 루트가 된다. (찾는 시간이 빨라짐)

- bst (이진 탐색 트리)
  - 좀 더 구현하긴 어렵지만 더 효율적인 구조
  - head 값을 기준으로 가장 최근값을 찾으면됨



- 구현1
  - 연결리스트를 이용한 풀이





### table calculator 2

- 액셀식 계산 + 순환 참조를 캐치
- 순환 참조가 트리식으로 구조가 생김 - bfs 로 순회, 재귀

