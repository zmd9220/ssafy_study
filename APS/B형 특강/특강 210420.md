# 특강 210420



### dp문제를 푸는 법에 대한 팁

- dp[n] = (dp[0] ... dp[n-1]) 의 값 들을 이용하여 구함 (수열과 유사)
- dp 배열을 만드는법? - dp[n] 번째를 얻기 위해 필요한 정도
- 0 ~  n-1 까지의 결과는 모르지만 알고있다고 가정하고 진행 (귀납적) - 1번
- 위의 방법으로 모른다면 0, 1, 2, 3 의 실제 값을 구해보고 서로 값들 간의 관계 (특정 값+ 선형으로 커짐 등)
- 위의 두가지로 모두 다 풀 수 있는건 아니지만 어느정도의 문제는 이 방법으로 접근 가능



###  LCS 문제설명

- 수열(문장) - 공통 부분 수열 중 가장 긴 길이를 구해야 한다. dp = 가장 긴 길이의 값들을 넣을 배열
- substring - 부분 문자열 - 연속성을 가진다. 
- subsequence - 부분 수열 - 연속성을 가지지 않아도 된다. 
  - ABCDEF -> BCD - 부분문자열 o, 부분수열 o
  - ABCDEF -> ACF - 부분문자열 x, 부분수열 o
- 즉 부분 문자열은 부분 수열의 부분집합

#### 먼저 브루트포스로 접근한다면 O(2^n)

- x와 y에 대한 모든 부분 수열을 구한다.
- 서로 일치하는 부분 수열중 가장 긴 길이를 찾는다.
- x = x0x1 ... xn-1 이라고 할 때 부분 수열을 만드는 과정
  - x0을 고를지 안고를지 - 2
  - x1을 고를지 안고를지 - 2
  - ... xn-1 을 고를지 안고를지 - 2
  -  -> O(2^2)
  - 만약 len(x) = 50이라면 약 1100조

#### DP로 접근한다면 O(n^2)

- lcs 문제는 더 작은 부분 문제로 쪼갤 수 있다.
- x = banana, y = nayana
- 양쪽의 공통 부분 수열인 ana 를 지우고 생각해보자.
- x = ban, y = nay - 이 두 수열에서의 lcs는 n이 된다 (혹은 a)
- 여기서 앞에서 지웠던 ana를 합치면 nana가 되고 이것이 원래 수열의 lcs이다.
- 이것을 점화식으로 하면
  - xn = ym 일 때
    - lcs(xn, ym) = lcs(xn-1, ym-1) +1
  - xn != ym 일 때
    - lcs(xn, ym) = max(lcs(xn-1, ym), lcs(xn, ym-1))
- 사용되었던 문자열을 출력하라 -> 뒤에서 부터 탐색해서

- 비슷한 문제 편집거리
- [n] [m]
  - [n-1] [m-1] n,m 길이가 같을때
  - [n] [m-1]
  - [n-1] [m]
  - 배열 2개로 메모리를 줄여서 풀 순 있음 - pdf 참고





### All pair shortest path

- 최단거리 -  다익스트라
- 사이즈 N (정점 V) <= 500 ,  M (간선 E) <= 50만
- 사이즈 v, e 차이가 매우 크다 -> 풀이법으로 플로이드 워셜 알고리즘을 생각해보기
- 우선순위 큐와 인접리스트를 쓰면 o(v^2) -> o(eloge)
- 보통 이러한 최단거리는 간선의 갯수를 많이주고 정점을 적게주므로 v < e
- 동적계획법의 플로이드 워셜 알고리즘을 이용하여 풀어보기
  - i - > j 에서 가는길에 k라는 길을 돌아 가는게 더 짧을 수 도있음
  - 즉 i -> j 에서 가는 길에 더 빠르게 돌아갈 수 있는 k라는 길이 존재하는지 여부를 찾기
  - k에 대해 1~v 까지 for문, i , j도 for문 1~v 까지
  - 이런식이면 O(V^3) - 3제곱이라 많을 수 있는데 정점이 약 500개고 간선의 개수는 최대 50만개 이므로
  - 참고 - shortest path fast algorithm, 벨만포드(음수 가중치까지 고려) 등은 알아둬서 나쁜것은 없음



#### 플로이드를 이용하여 문제 접근

-  점화관계
  - Dk[i] [j] = min(Dk-1[i] [j])
- 그림으로 보면서 이해하기
  - 자기 자신에서 자기 자신을 방문하는 cost - 0 1,1 2,2 등은 다 0이라는 뜻
  - 인접행렬 정도로 작성 - 초기값을 작성 할 때 범위 고려 (현재 간선 가중치 합보다 큰 수(10억 이런거) or -1 과 같은 음수와 같이 절대 계산으로 나올 수 없는 수 - 이번문제에선 음수가 나오므로 -은 불가)
  - 일단 직접 갈수있는 최단거리 작성
  - 그리고 특정 정점을 거쳐서 지났을 때 만날 수 있는 정점의 최단거리를 기존 값과 비교해서 넣기







- 내일 문제는 문자열파트의 단어가 등장하는 횟수, 두번이상 등장하는 문자열 문제 진행 예정입니다.

- 문자열 kmp , sa+lcp? 어렵다 -> 해시가 짱
- 내일은 해시 알고리즘 중심으로 - 라빈 카프 알고리즘





### 타일링 문제

- dp의 대표적인 문제 중 하나 (백준에서 풀어봄)
- 2*n의 직사각형을 1 * 2 타일과 2 * 2 타일을 이용하여 채우는 방법의 수를 구하여라 
- dy = 방법의 수 배열
  - 뒤가 2*2 타일로 덮이는 경우 dy[n-2]
  - 1*2 타일에 덮이는 경우 dy[n-2] 밑의 공간  채울 방법이 같은 1 * 2 짜리를 넣는 방법밖에 없기 때문에 n-2와 같다
  - 2*1 타일에 덮이는 경우 dy[n-1]
  - dy[n] = dy[n-2] + dy[n-2] + dy[n-1] (n >= 3) dy[1] = 1, dy[2] = 3
- 다만 이 문제에서는 정수의 범위가 매우 크다 
  - dy[31] = 1431655765
  - dy[63] = 6,148,914,691,236,517,205
  - n은 250까지 가능하다고 주어졌기 때문에 컴퓨터에서 제공하는 자료형 보다 큰 정수형을 구해야함
  - JAVA의 경우 Big Integer 기능을 쓰면 되지만 c, c++은 직접 구현해야함
  - b형의 경우 자바도 직접 구현해야하므로 다양한 방법 중 받아올림 방법을 통해 배열로 생성
  - 각 배열의 자리수에 따라 10의 자리씩 나눠서 담기 불러올땐 10^i로 불러오기
  - 더하기 구현 = 일단 모두 덧셈 후 10을 넘어가면 현재 자리에 -10, 다음 인덱스에 값+1 해주기
  - 출력은 0이아닌 첫 숫자부터 맨 앞까지 출력 

