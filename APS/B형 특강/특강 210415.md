# 특강 210415



## 3947. [Professional] 가장 짧은 길 전부 청소하기

[https://swexpertacademy.com/main/solvingProblem/solvingProblem.do?contestProbId=AWH998YaEa0DFAUG&categoryId=AWH998YaEa0DFAUG&categoryType=CODE#collapseOne]

- 이 문제는 힙(max heap), 다익스트라 알고리즘을 필요로함
- 일반적인 다익스트라 알고리즘은 min heap을 사용하지만 -를 쓰면 max heap이 됨



### HEAP

- 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전 이진트리를 형태를 기본으로 한 자료구조
- 완전이진트리이므로 높이가 log n이 보장됨
- 필요 요소 - 원소 삽입
- 최대 / 최소 찾기 - peek / pop
- 구현이 쉬운편이라 자주 사용됨
- treap? - 랜덤성? 레드블랙트리? avl 트리?
- max heap의 연산 및 특징 - 현대 최댓값 관찰(top) 최댓값을 제거(pop) 어떤 값을 추가(push)
  - 부모 노드가 항상 자식 노드보다 크거나 같다.



#### max heap의 구현

- 위의 줄부터 힙의 번호를 붙일 수 있음(완전 이진트리 이므로 가능) - 배열에 저장(1번부터 or 0번부터)
  - 이렇게 저장하면 왼쪽자식은 자신 * 2, 우측자식은 자신 * 2+1 로 갈 수있음
  - 일반 트리라면 포인터 나 별도의 배열로 관리해야하는데 이진트리이므로 이렇게 구현이 가능
- top은 루트보면 됨
- push 기능을 만드는 법 - 이진트리의 가장 우측에 넣고(9개가 있으면 10번 인덱스에) 조상 노드를 찾아가며 크기 비교(루트까지 가되 자신이 막힐 때 까지(조건이 안될때까지))
  - 새로 추가된 값으로 인해 해당하는 부분만 힙의 조건을 깨기 때문에 해당하는 부분만 바꿔주더라도 다른 곳의 힙의 성질이 깨지지 않는다. (새로 들어온 값이 상위 노드로 올라가더라도 새로 들어온 값이 기존 부모 노드의 값보다 크기 때문에 어차피 바뀌어도 위치관계가 바뀌진않음)
- 최대값 삭제
  - 루트 삭제 후 가장 최하단(가장 마지막 인덱스)를 루트로 올림
  - 바로 밑의 자식 중 큰 값을 루트로 올리고 변경
  - 파이썬은 heapify 라이브러리로 사용가능 (리스트로도 구현은 가능)



#### 다익스트라 알고리즘

- n개의 정점, m개의 간선 간선의 정보는 a_i -> b_i, 가중치 c_i가 주어진다.
- 어떤 정점 S(start)로부터 다른 모든 정점까지의 최단거리는 무엇일까?
- aparell ? aps? floyd-warshall
- 가중치가 음수가 될 가능성이 있다면 bellman-ford (거의 안나옴)
- 단방향 그래프를 처리가능하면 양방향 그래프도 처리 가능(오는 간선만 추가)
- 다익스트라 - dp
  - 1번 정점 부터 i번 정점까지의 최단경로를 Dis[i] 이고, Dis[1] = 0이다(안움직이니)
  - 최단거리가 확정이 되지 않은 노드 중, Dis[i]값이 가장 작은 노드(v)를 고르고 해당 노드는 최단거리를 확정한다.
  - 그 노드로 부터 이어진 간선들을 이용하여 Dis[w] 들을 갱신한다.
  - 모든 노드가 확정되기 전까지 1, 2 과정을 반복한다.
  - 예시를 보면서 파악 - 정당성 (증명)
    - 직관적으로 간단히 설명한다면 - 최단거리가 확정되지 않는 노드 중, Dis[i] 값이 가장 작은 노드를 고르지 않는다.
    - 최단거리가 확정된 노드들을 통한 최단거리는 다 선택이 됐는데 만약 아직 최단거리가 확정되지 않은 노드들에서 해당 최단거리로 갈 수 없다.
    - 예를 들면 서울에서 부산을 갈때 서울에서 대전들려 부산가는 것과 서울에서 일본갔다가 부산가는건 당연히 대전을 들리는게 더 빠르다
    - 증명을 한번? 읽어보기?
  - 단순히 이렇게 짜면 O(n^2) 으로 느리다.
  - 개선책을 찾아보자 - 인접행렬을 쓰면 느린데 특정 행렬에서 인접리스트로 바꾸면 O(OutDegree(V)) - outdegree 는 간선하나당 하나씩 추가 전체라고 보면 간선의 수인 O(m) 시간복잡도가 나온다.
  - 이렇게 바꿔도 아직 O(n^2)
  - 그럼 최솟값 찾는 부분을 heap으로 바꾸자 (log n 시간으로)







### 실제 문제 풀이

- 많이 어렵고 생소한 알고리즘을 사용함
- 최단경로가 하나가 아닐 수 있음
- 해당 간선만 사용해서 최단경로로 갈 수 있어야함
- 추가로 사용한 간선이 사용됐을 때 더 빠르면 안됨
- shortest path DAG - 다익스트라 스패닝 트리?
- DAG directed acylic graph (방향이 있고 빙글빙글(특정 몇개의 곳이 계속 돌게 되는 사이클)하지 않는 그래프)
  - 애초에 사이클이 생기면 특정 지점에 대한 최단경로를 구할 수 없다. (사이클 도는 곳의 값이 얼마난지 모름)
  - 기존 다익스트라는 최단 경로만 알려줬음
  - 이제는 어디서 왔는지 루트도 알려줘야함 - 근데 최단 거리만 알아도 최단 경로를 역추적 가능함
    - 간선 하나하나가 최단경로에 포함되는 경로인지 알 수 있음
    - 이 간선을 지났을 때 b까지의 최단거리가 나오면 해당 간선을 이용했음을 알 수있음
- 최단거리, 방향성이 있어서 mst 와 다름(mst - 미니멈 스패닝 트리 - 최단거리와 방향성 보장 X)
- 다익스트라를 기준으로 DAG 까지 만든다
  - 근데 이렇게 하면 특정 노드에 들어오는 간선이 너무 많다.(같은 최단거리 일경우)
  - 그래서 들어오는 간선을 하나만 있어도 충분하니까 엣지(간선) 가중치가 가장 작은 것으로만 남기자
  - 





#### 내일문제

고속도로 건설, 간담회 참석 - 그래프