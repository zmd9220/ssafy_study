# 특강 210413



### 들어가며

- 어제의 최소한 절반과 이번 평등문제는 브루트포스로 풀 수 있게 만들어 뒀지만 실제 브루트 포스로 풀면 o(n^2) 으로 인해 약 10~20만의 샘플케이스 데이터 량으로 인해서 시간 안에 풀 수 없게 됨. 그래서 최적화를  통해 o(n) 수준에서 문제를 풀 수 있도록 알고리즘을 구성해야함
- 코딩 대회나 코테 등에서 자주 등장하기 시작하는 문제
- 입력 사이즈를 보니 브루트 포스로 안될 것 같을 때 이 문제를 1. 다수의 결정 문제로 치환하고, 2. 연속성을 찾아본다.



### 평등주의

- 문제 설명 - 
- 문제 변환(결정문제)
  - 결정 문제 - 특정 주어진 문제에 대한 정답이 항상 yes or no (t/f)로 대답할 수 있는 문제
  - 다수의 결정문제로 치환, 연속성을 찾으면 이분 탐색이 가능해짐
  - 인접한 숫자 차이의 최댓값을 최소로 하여라 -> 인접한 숫자 차이가 1 이하가 될 수 있는가? ... 인접한 숫자 차이가 w 이하가 될 수 있는가?
  - yes or no 로 가능한 문제가 됨
  - 인접한 숫자 차이가 1 이하가 될 수 있는가? 가 가능한지 한번 체크해보자 (테스트 케이스 1번으로)
    - -1, -3, -3 으로 7번의 연산이 필요함 -> 최대 4번 연산이므로 불가능 (no)
  - 인접한 숫자 차이가 2 이하가 될 수 있는가? 
    - 4, 5번에만 -2, -1 로 3번의 연산 -> 최대 4번 내 연산이 가능 (yes)
  - 즉 좌에서 우로 우에서 좌로 배열의 크기를 보면서 해당 w가 가능하도록 값을 변경시키는 과정 자체는 o(n) 이지만 전체 w는 최대값 - 최소값의 갯수이므로 w는 n과 거의 유사한 값 즉 o(nw) = o(n^2)과 유사 그래서 단순히 이정도 까지로는 문제를 풀 수 없다.
  - 다시 보았을 때 인접한 숫자 2 이하 가 가능할 때 3 이하도 가능하다 -> [3 이하]는 [2 이하]의 부분집합 이기 때문
  - 특정 k 에서 yes가 나오면 k+1 ... w 까지는 모두 yes
  - 특정 시점에서 yes가 등장하면 그 이후 값은 모두 yes
  - 특정 시점에서 no가 나오면 그 이전의 값은 모두 no
  - 그래서 특정 지점을 잡고 거기가 yes면  그 이후는 yes이므로 볼 필요 없다 -> 이분 탐색 처럼 yes 이후를 버리고 탐색구간을 왼쪽으로 축소
  -  no 쪽을 탐색 특정시점에서 no 면 해당 왼쪽은 다  no -> 우측으로 탐색 범위를 축소
- 이분 탐색(parametric search)
  - 재귀나 while for로 사용으로 구현 



### 자신 풀이

- 입력사이즈로 시간복잡도를 구상 이후에는 어떤 알고리즘으로 풀 수 있는지 생각 시간복잡도가 오래 걸릴만한 문제면 log n으로 치환할 수 있는 방법에 대해 여러 테크닉을 생각해본다.



### 최대 부분 배열

- 아이디어가 중요한 문제 - 아이디어를 알면 쉽게 구현 가능하지만 모르면 골치아픈 문제
- 알고리즘은 공식이 없지만 유형은 있다.
- 문제 설명
  - 길이가 n인 배열 a[0..n]가 주어질 때, **부분 배열의 합** a[i]+a[i+1]+...+a[j]의 최댓값을 구하여라
  - 구간합을 빠르게 구하는 것이 중요 -> 소개할 방법으로 가볍게 가능
    - 구간합을 구할 때 값의 update가 선형 만큼 발생한다(자주) - 팬윅트리, 세그먼트 트리, 인덱스 트리 (팬윅은 배열의 인덱스를 이용해 배열을 트리처럼, 세그먼트는 진짜 트리 구현 둘의 방식은 비슷) 인덱스 트리 -> 정통파 구현이 어려운대신 시간이 빠름
    - 값이 업데이트 되지않는다 -> 누적합(배열)만 구하면됨
  - invers 카운트? -> 트리로도 구현가능하고 분할정복으로도 구현 가능
- 누적 합 수열
  - 누접 합을 구하면 모든 부분 배열을 만들 필요가 없어진다.
  - [2, 7] 구간의 부분합은? sum[7] - sum[1] = -9 = sum[end] - sum[start-1]
  - sum 배열 작성 o(n) + 부분합 구하는 o(1) + o(1) 
  - i, j 가 만들 수 있는 조합의 수는 n^2 이라 o(n^2) 이 걸림 -> 시간 초과
  - 부분합, 구간합을 빠르게 구할 수 있는 성질을 배워보자(dp)
- dp
  - 누적합 배열을 좀 살펴보면 a[1] + a[2] + a[3] + a[4] < a[4] (6 < 7)
  - 특정 칸 까지의 구간합이 음수라면 다음 인덱스는 무조건 합을 더하면 손해 그러므로 혼자 사용하는것이 더 이득
  - 그래서 직전까지의 부분합과 현재 값과 비교 했을 때 크기가 큰 쪽(이럴 경우는 보면 직전까지의 부분합이 음수일 때)을 확인해서 누적합 배열에 넣어주기



- 코테가 목표다 -> 익스퍼트 문제를 무난히 구현할 수 있으면 코테 통과할 수 있음
- 코드그라운트 루트, 솔빙클럽
- 요즘 출제 동향 문자열 파싱 관련 라이브러리 없어도 사용할 수 있도록
- knp 문자열 관련해서 해시알고리즘이 구현이 쉬워서 추천? 
- 문자열 라이브러리 사용, 구현 가능한 정도?



- c++ 입력 받는법 (문자열)
- 1,2,3,4,5 scanf("%d,")
- 111111111 scanf("%1d");

