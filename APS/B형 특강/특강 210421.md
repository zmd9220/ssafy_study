# 특강 210421



## 문자열

- 문자열 알고리즘은 너무 어렵다.
- kmp (접두사, 접미사) - 암기식, 적용하기 어렵다..
- 문자열에서 대부분의 문제에서 사용가능한 퍼포먼스를  가진 알고리즘 - 해시를 이용하여 구현 (현업에서도 자주 쓰임)
- 오늘은 해시알고리즘을 중심으로 진행 될 것





### 라빈-카프(rabin-karp) 알고리즘 - 

- o(n) - 해시가 충돌이 나지 않는 다고 가정할 때 - 충돌을 줄여서 시간을 올림

- f("문자열") = 값 

- f() - 해시함수 , "문자열" - key, 값 - value 

- 항상 특정 key에 대해 특정한 value를 반환해야함 - 어떤 예외도 없이 모두 value를 반환해야함

- 동일한 key 값에는 동일한 value 값을 반환해야함 - 여러 번 실행해도 항상 같은 결과를 얻어야 한다.

- key값이 다르면 value값이 다를 확률이 높음 - 같으면 충돌, 그러므로 다르면 다를 수록 좋다. - 즉 충돌을 줄여야 좋다.

- 문제를 풀 때 주로 사용되는 해시 함수는 다음과 같다.

  - s = "an-1an-2 ... a1a0"
  - f(s) = a0d^n + a1d^n-1 + ... + an-1d^0 (mod m)
  - 즉, f는 s를 d진법으로 쓴 것을 m으로 나눈 나머지 이다.

- 문자열 문제에서 출제자가 정말 해시를 막기 위한 특정 수단을 쓰지 않는이상 거의다 풀기 가능하다.

- 다만 출제자가 막으려고 해도 어느정도는 회피해서 구현할 수 있다.

- % 를 하는 이유는 배열의 범위는 한정되기 때문에 [0 ~ m-1] - 무한정 늘릴 수 없음

- 그래서 %를 사용하다보니 충돌이 발생함 (7 % 2 = 1, 5 % 2 = 1), 이러한 충돌을 가능한 줄이자

- 문자열은 문제에서 제공 되지만 어떤 진법으로 나눌지 d 와 나눌 기준인 m을 어떻게 정할까?

  - 우선, 해시의 충돌 확률은 m의 크기에 비례한다 - 충돌 확률 2개가 만나 1/m * 1/m 이지만 d때문에 조금 더 크다
    - m은 소수여야 좋다 - 공약수가 나오면 충돌 가능성이 올라감 = 두 개의 값이 서로소여야 충돌 확률이 낮다.
    - m의 크기를 가능한 최대로 늘려보자 m = 2^64
  - d의 값은 key값의 수 보다 크면 좋다.
    - 예를 들어 d를 2로하면 1*2^n = 2 * 2^n-1 - 어디서 나온 데이터인지 모름, 충돌
    - 소수를 사용하는 것이 좋다.
    - char형(255) 보다 큰 257, 259 를 이용하자.
    - 또는 str-'a' = 0~25
  - 위의 제시대로 계산하면 257 / 2^64 로 매우 충돌 확률이 적다
  - unsigned long long의 오버 플로우를 이용하면 mod 2^64 연산을 쉽게 할 수 있다.
    - unsigned long long = 2^63
    - 2^63 + 1 = 맨 최상단 1버리고 다 0이됨 = 0

- 여기까지 해시 (rabin fingerprint) 의 설명

- 그렇다면 라빈-카프 알고리즘은?

  - 슬라이딩 윈도우 방식의 알고리즘
  - 한칸씩 움직이면서 특정 서브 문자열을 찾을 때 매번 계산을 진행하면 비효율적
  - 공통으로 들어가는 부분의 패턴을 적용해서 계산을 줄이기
    - banana에서 nan을 찾을 때
    - f(ban) =  b* d^2 + a* d^1 + n * d^0
    - f(ana) =  a* d^2 + n* d^1 + a * d^0
    - f(ana) = (1){f(ban) - b * d^2} * (2)d + (3)a * d^0
    - 모듈러 연산에서 %가 들어가지 않는이상 +, -, *는 결과에 영향을 미치지 않는다.

- 라빈-카프를 이용해 풀려면

  - s에 대한 해시를 구한다.

  - b에서 부분 문자열의 길이가 |s|인 모든 해시를 구한다. - 라빈-카프 알고리즘을 이용하면 두번째 해시부터 O(1)로 구할 수 있다.

  - O(|t|), O(|s|-|T|+1) -> o(|s|+|t|)

    

- 출제자는 일부러 충돌이 날 수 있는 데이터를 넣을 수 있음 - 자주사용되는 2^64, 257 과 같은 수

- 이러한 충돌 회피를 위해선 구글 검색?

  - mod로 자주 사용하고 싶은 소수로 골라서 사용 222219
  - d 도 300대 쯤의 소수로 하나 골라서 아무거나 넣고 만약 이렇게 했는데도 에러? 그럼..

- 해시는 구현도 5~10줄 정도로 짧고 편하기 때문에 사용 강추

- 해시의 강력한 기능은 문자열을 인덱스처럼 사용이 가능하다는 점(키 값이므로)



- 해시 같은경우 강력한 기능이라서 문자열 문제 말고도 다른 문제가 존재 할 것 같은데 어떤 유형의 문제에서 사용이 가능할까요? 또 여기서는 하나의 값을 가지고 매번 연산을 해주면 되지만 실제 해시테이블처럼 배열같은 곳에 값을 넣어놓고 사용하게 됐을 때 mod를 2^64로 하게 되면 배열 크기도 2^64로 잡아야 되나요?

- 단순한 한번의 값을(두개의 계산으로 끝이면) 계산할 때는 value가 표현할 수 있는 맥시멈을 기준으로 나눠주는게 범위가 가장 크므로 충돌 확률이 적다.
- 배열의 인덱스로 사용해야 한다면(해시 value를) 0~k 를 메모리 에 맞춰서 조정해주면 됨
  - 또한 충돌이 일어났을 때 어떻게 처리할 건지 (체인으로 연결-링크드리스트 or 빈칸을 찾을때까지 이동 후 저장)
  - 충돌했을 때 가져오기 위해서 처리법
- hashmap (자바), map,set(c++), dictionary(python)



### kmp 알고리즘

- o(n)







### 두 번 이상 등장하는 문자열

- satlcp (sufiix array + lcp) - 정석 - o(n)은 논문급, o(nlogn) - 일반적
- 라빈 카프 - 해시 - 날로먹기



- k가 가장 긴 두번 이상 나오는 문자열이라면 1 ~ k-1도 두번 이상 나오는 문자열임 (문자 하나를 제거해도 같은 문자가 제거된 문자열 이므로)
- 코테에서





### 질문

- 금요일 그래프 관련 알아야할것 
- dijkstra - 다익스트라 알고리즘의 개념, 주어진 문제가 시간 최적화를 많이해야하므로
  - 인접리스트, 우선순위큐 등을 통해 최대한 최적화하여 O(ElogE) 시간에 풀도록하기
- MST - prim, kruskal 알고리즘