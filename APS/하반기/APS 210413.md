# APS 210413



## 오전



### [S/W 문제해결 응용] 1일차 - 단순 2진 암호코드

- 관찰 1. 모든 암호코드들은 끝이 1로 끝난다. 
- 관찰 2. 암호코드의 끝자리는 1이므로 마지막으로 나온 1로부터 56개의 문자열이다.
- 뒤로부터 탐색하여 1을 찾으면 거기서 앞의 56개 문자열을 가져오고 그것을 토대로 암호코드 확인을 한뒤 결과 반환





### 5185. [파이썬 S/W 문제해결 구현] 1일차 - 이진수

- 16진수를 2진수를 바꾸는 방법에 대해 복습





### 5186. [파이썬 S/W 문제해결 구현] 1일차 - 이진수2

- 소수부를 2진수로 바꿀때 어떻게 바꿀지 복습
- 정수부 10진수를 2진수로 바꿀때는 2로 나누고 거꾸로 적어주면 됨(가장 마지막에 나온 숫자가 맨 앞)
- 소수부 10진수를 2진수로 바꿀때는 2를 곱하고 1.xx 나오면 1, 0.xx 나오면 0 소수부는 그대로적으면 됨
- ex) 0.625 = 0.625 *2 = 1.25 -> 1, 0.25 *2 = 0.5 -> 0, 0.5 * 2 = 1.0 -> 1, 0.0 종료 0.101



### 10726. 이진수 표현

- 별로 어렵지 않은 문제
- 이진수 특정자리 밑으로 모두 1이 되어야함을 유의



<br>

---



## 오후



### 1242. [S/W 문제해결 응용] 1일차 - 암호코드 스캔

- 어렵다.. D5
- 어제와 달라진점 - 16진수로 제공되는점, 코드가 1개만 아닌 여러 개의 암호코드가 나온다는점, 코드 사이에 0이 나올 수 있다는 점, 암호코드가 56의 배수 (얼마나 긴 암호코드인지 모르는 점)
- 내가 생각했던 구현 과정

  - 뒤에서 부터 0이 아닌 수 부터 i-1이 0인 수까지 입력을 받고 문자열로 넣는다.
  - 해당 문자열을 바이너리 코드로 만든다.(2진수)
  - 2진수 된 배열을 토대로 비율에 따라 문자열을 나눈다. (이미 문자열 크기는 56, 112, 등 56의 배수이므로 해당 비율에 맞춰서 나누면됨)
- 문제가 된 경우 
- 뒤에서 부터 0이 아닌 수 부터 i-1이 0인 수까지 입력을 받고 문자열로 넣는다. - 이부분에서 문제가 되었음.
  - FF000F0F0FFFF0FFFF0F000F0FF0FF000F00FF00F0FF000F000FF0F와 같은 경우 바이너리를 만들 경우 문자열의 크기가 220인데, 분명 일반적인 암호코드라면 56의 배수 근처에서 끝이나야되는데 이것은 224와 4차이로 데이터를 어디서 흘렸는지 찾을 수 없음.. 즉 내가 구상한 답안 자체가 잘못되었다는 것.
- 결국 구글링을 통해 문제 해결 방법을 찾아 봤는데 방법은
  - 먼저 데이터를 받고 이진화를 줄마다 먼저 시켜준다. (배열 전체를 바이너리화)
  - 해당 암호코드의 숫자가 가지는 비율을 보았을 때, 2:1:1 - 0 , 2:2:1 - 1 등 다를 지라도 비율에 따른 나오는 코드 진행이 0, 1, 0, 1 로 동일하다.  여기서 0, 1, 0, 1 = [1] [2] [3] [4] 라고 하면
    - 어차피 뒤의 1, 0, 1의 비율만 찾아내면  앞의 비율은 확정이 되고, 그에 따라 나오는 값은 고정 (2:1:1 -> 3:2:1:1 -> 0 확정)이 되기에 맨 앞의 0([1])은 구할 필요가 없다. 즉 1, 0, 1의 비율을 뒤에서 부터 탐색하면서 찾아나가야 한다.  [2], [3], [4]
    - 왜 뒤에서 부터 찾아야 하나? 항상 암호코드의 숫자는 1로 끝나는 것은 보장되지만 앞에서 부터 보았을 때 0부터 시작인 것은 아는데 어디 부터 시작되는지 알 수 없다. (더미 코드들은 다 0으로 되어있기 때문) -> 즉 뒤에서 부터 만났을 때 1을 만난다 = 여기가 마지막 [4]번 범위라는 뜻이 확실하기 때문
  - 위에서 나온 조건 대로 가장 최근에 나온 1의 갯수를 세면 [4], 그다음에 0이 나오면 [3], [3]을 세는 도중 1을 만나면 [2], [2]를 세는 도중 0을 만나면 [1]이 된다. [1]이 나오는 순간 [2], [3], [4]의 비율은 다 구해졌으므로 세 수의 비율을 셋 중 최소값으로 나누어 맞추면 암호코드의 숫자를 알게 되고 이것을 디코드 배열에 넣는다.
  - 이후 디코드 배열의 크기가 8이되면 8개의 연속된 암호코드 숫자열을 찾았다는 뜻이므로 원래 하던 올바른 암호코드인지 확인 하되, 현재 문제에서는 똑같은 암호코드가 중복되어 나오므로 중복 체크까지 고려해야한다. -> 1. 올바른 암호코드인지 확인 2. 현재 암호코드가 이미 나와서 계산이 끝난 암호코드인지 확인
    - 2번을 위해서 항상 현재 암호코드가 중복이 아니라면 암호코드 중복을 막기위한 배열에 넣어줘서 다른 중복이 오지 않도록 방지 해준다.
  - 두 작업에 이상이 없으면 정답 부분에 더 해주고 이 작업을 반복하면 결과값이 나온다.
- 결국 요점은 데이터 처리부분은 내가 생각한 것과 크게 다르지 않았는데 2차원 배열에서 데이터를 뽑아내는 부분에서 생각의 차이가 있었고 이 부분이 나혼자 못풀게 된 원인 인것 같다.

