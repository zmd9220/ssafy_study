# APS 210423 - 문제풀이



### 5247. [파이썬 S/W 문제해결 구현] 6일차 - 연산

- 연산 결과에 대한 상태 트리를 만들고, bfs로 탐색해본다.
- 이미 만든 자연수는 다시 만들면 연산 횟수가 늘어나므로 만들지 않기
- 연산 결과가 1이상 100만 이하면 인접 정점
- 일반 리스트 사용시 시간초과 - list.pop(0) 는 스택기반이므로 앞까지 탐색하는 시간 - o(n)
  - 선형 큐를 선언하고 front/rear 인덱스 사용 - o(1)
  - deque (deck - double ended queue) 객체 사용
    - 양쪽 끝에서의 추가와 팝 시간이 비슷 - o(1)





### 5248. [파이썬 S/W 문제해결 구현] 6일차 - 그룹 나누기

- 상보 배타 집합의 개념을 이용하여 그룹을 짜주기
- make_set, find_set, union 이용
- 마지막에 for문으로 각 원소별 대표원소의 갯수 (find_set)를 세면 답
- 입력 받고 대표원소 초기화 - make_set
- 각 입력을 2개씩 잘라나가며 union
- 대표원소 찾기 = find_set으로 갯수 세기 or p[i] == i (자기자신 번호와 대표원소 번호가 같은 인덱스)



### 5249. [파이썬 S/W 문제해결 구현] 7일차 - 최소 신장 트리

- prim or kruskal을 이용하여 MST(minimum spanning tree) 구성
- 문제를 보다 보면 한참 후에 mst라고 알게 되는 문제도 있음(응용버전), 여기는 연습문제이므로 대놓고 알려줌
- 프림은 아무 점이나 잡고 시작하고 크루스칼은 간선 정렬하고 시작한다고 외우면 편하더라고요
- 노드로 보느냐 - prim 간선으로 보느냐 - kruskal
- sort, sorted 나 직접 quick_sort, merge_sort, heap_sort 중에 하나를 만들어서 사용하기
- sort, sorted 사용시 입력을 가중치 먼저 받으면 lambda 사용 안해도되고 일반입력으로 받을 경우 x[2] 기준으로 정렬해야 가중치 기준으로 정렬됨

#### kruskal

- kruskal 기준으로 n-1개의 간선을 선택이 완료되면 종료 (종료 조건)
- 가중치를 기준으로 꺼내되 현재 꺼낼 간선이 사이클이 형성되지 않는다는 기준 (find_set(u) != find_set(v))
- 간선이 꺼내지면 가중치를 합해주고 v의 대표원소를 u의 대표원소로 바꿔주기 
- 만약 sort 없이 버블, 셀렉션 소트를 하면 mst를 사용한 의미가 없어짐 o(n^2)
- 그러므로 직접 정렬을 구현하면 nlogn 정렬을 사용해야함
- 병합 정렬에서 리스트 슬라이싱으로 하면 그 크기를 줄이고 재복사하는 시간이 걸리므로 시간이 걸림. 그러므로 인덱스로 구간을 나눠가야함 - deque 가 pop이 o(1)이라도 새로운 배열 생성에 시간이 걸리므로 비추 - 인덱스 접근이 최적화

#### prim

- extract_min(q) 부분이 핵심 - mst에 포함되지 않은 정점 중 key 값이 가장 작은 정점(mst 연결 비용이 최소인 정점)을 찾기
- MST에 포함된 집합, 포함되지 않은 집합 2개 - 풀이에선 mst, pi
- 모든 정점이 mst에 포함될 때 까지 for _ in range(V)
  - mst에 포함되지 않은 정점 중 key[u]가 최소인 u 찾기 u = extract_main(MST, key, V)
  - key[u]가 최소인 u를 mst에 추가 (찾은 순간 이 정점은 mst 정점으로 포함된 걸로 침) - MST[u] =1
  - u에 인접인 v에 대해

```python
# 핵심 부분
for _ in range(v):
    u = extract_min(mst, key, v)
    mst[u] = 1
    for v in range(start, v+1):
        if mst[v] == 0 and adj[u][v] != 0:
            if key[v] > adj[u][v]:
                key[v] = adj[u][v]
                pi[v] = u
return sum(key[start:])
```





### 5250. [파이썬 S/W 문제해결 구현] 7일차 - 최소 비용

- djikstra 이용
  - 그래프의 정점 번호 대신 행과 열의 좌표를 이용한다.
- 4방향 델타
- bfs로 접근
  - 비용이 갱신되는 경우가 더 이상 없을 때 까지 반복한다.
- d 는 최단 거리 배열, u는 현재 좌표에 방문했는지 체크하는 배열
- 0, 0 에서 갈 수 있는 거리를 작성해주고 u에 체크 안되있는 배열의 나머지 부분 중에서 가장 최단거리인 좌표를 찾기 - 다음 좌표가 됨 - 1번 예제에선 1,0이 선택됨

```python
def dijkstra(n):
    INF = 10000
    d = [[INF]*n for _ in range(n)]
    u = [[0]*n for _ in range(n)]
    d[0][0] = 0 # for 모든 정점 v : d[v] <- a[s][v]
    for _ in range(n*n): # while u != v
        wi, wj = 0, 0
        minV = INF
        # 여기 부분이 시간이 매우 오래 걸림
        for i in range(n): # d[w]가 최소인 정점 w 부분집합 v-u를 선택
        	for j in range(n):
                if u[i][j] == 0 and minV > d[i][j]:
                    minV = d[i][j]
                    wi, wj = i, j
       	u[wi][wj] = 1 # u <- u U {w}
        # 델타 검색
```

- 우선순위 큐를 사용한다면



- BFS 변형한다면
  - 내 인접 좌표에 대해서 최소값으로 갱신 될때 만 인큐
  - 다만 pop(0)를 사용하므로 덱을 사용해야 시간이 보장된다.
  - 중복된 값이 들어가는 경우가 꽤 많아서 n이 커질수록 속도가 현저히 낮아진다. (교수님 피셜 약 200 넘어가면)

```python
def f(n):
    d = [[1000000]*n for i in range(n)]
    d[0][0] = 0
    q = [(0,0)]
    while q:
        wi, wj = q.pop(0)
       	for di, dj in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
            ni, nj = wi + di, wj + dj
            if 0 <= ni < n and 0 <= nj < n:
                diff = h[ni][nj] - h[wi][wj] if h[ni][nj] > h[wi][wj] else 0
                if d[ni][nj] > (d[wi][wj]+diff+1): 		# 기존 보다 이동 비용이 적으면
                    d[ni][nj] = d[wi][wj] + diff + 1 	# 비용 갱신
                    q.append((ni, nj))					# 주변도 갱신될 수 있다.
    return d[n-1][n-1]
```





### 5251. [파이썬 S/W 문제해결 구현] 7일차 - 최소 이동 거리

- 다익스트라로 최소 이동 거리 계산
- 위와 유사하게 진행됨
- 인접 행렬로 구성시 본인의 인덱스 (0, 0), (1,1) 은 모두 0으로 초기화

```python
def dijkstra(s, v):
    u = [0] * (v+1)
    u[s] = 1
    for vtx in range(v+1):
        d[vtx] = adj[s][vtx]
    # while len(u) != v:
    for _ in range(v):
        minV = INF
        w = 0
        for i in range(v+1): # d[w]가 최소인 정점 w 부분집합 v-u를 선택
            if u[i] == 0 and minV > d[i]:
                minV = d[i]
                w = i
        u[w] = 1 # 선택된 집합에 포함
        for vtx in range(v+1):
            if 0 < adj[w][vtx] < INF:					# w를 거쳐 v로 가는 비용과
                d[vtx] = min(d[vtx], d[w]+adj[w][vtx])	# v로 가는 기존 비용 비교
```





### 7465. 창용 마을 무리의 개수

- 상호 배타 집합 이용
- 우리가 상호 배타 집합을 사용하는 이유 - 서로 분리 되어있는 트리, 그래프가 몇개인가를 찾을 때 사용 가능
- 트리나 그래프에서 서로 간의 노드 번호가 다르고 몇개로 나뉘어져 있다면 그것을 찾을 때 용이함
- 전체 영역에서 색칠된 공간 찾는 문제와 비슷? (상호 배타 집합과)
- 상호배타 집합의 findset 재귀로 하면 path compression 하기에 좋다. - 리턴과 동시에 모든 하위 원소들의 값이 대표원소로 값이 갱신됨





### 1795. 인수의 생일 파티

- 다익스트라 - 최단 비용만 구해짐
- 돌아가는 비용 - 1번을 시작점으로 하는 다익스트라 x - 시작행 y - 도착행 (1에서 나가는 비용)
- 나가는 비용 x - 도착행 y - 시작행 (특정 정점으로 들어오는 비용)

#### 추가설명

- 플로이드 워셜 - 경로까지 구하기
- dp는 특정 알고리즘이라기 보단 문제를 접근하기 위한 방법 중 하나라서 매번 문제에 맞는 점화식을 구성해야함.. 이게 제일 어려움.. 많이 풀어보면서 점화식 구성을 위한 연습을 해보는 것이 중요



## 오후 웹코칭

- 알고리즘 4문제
- 3문제 코딩 구현, 1문제 글로 분석, 설명, 답쓰는 문제
- 수업시간에 풀어봤던 문제, 다뤄봤던 문제를 중점으로 변형되더라도 큰 차이는 없는 수준
- 트리, 진수변환(비트마스크)
- 완전검색 - 순열, 베이비진
- 그리디 (회의실)
- 분할정복 - 병합, 퀵
- 백트래킹 - nqueen
- 그래프 기본 - dfs, bfs
- 상호 배타집합
- 최소신장트리 - prim, kruskal - 모든 정점을 포함하여 간선의 최대 합이 최소인 트리
- 최단 비용 - 다익스트라, 벨만포드(음수) -> 경로까지 찾기? -> 플로이드워셜
- 최소 2문제는 풀어야 과락 x
- 중요하다고 생각 하는 부분 - 완전탐색 + 컷팅(백트래킹) - 베이비진 등, 순열 관련된 문제, 최소신장트리, 다익스트라 알고리즘, 정렬과 탐색(이분탐색 -> 퀵, 병합정렬)



## 오후 라이브





### 1251. [S/W 문제해결 응용] 4일차 - 하나로

- 섬을 정점, 섬을 잇는 해저 터널을 간선으로 생각
- 모든 정점에 대한 연결을 갖는 완전 그래프에서 mst를 찾는 문제
- 모든 연결에 대한 비용을 미리 계산해 인접 행렬을 만들어 놓는다.
- 거리의 제곱 - c^2 = a^2 + b^2
- 가중치를 애시당초 거리의 제곱으로 하여 대각선,  가로, 세로 별로 가중치 계산하여 각 노드에서 진행하는 가중치 모두 계산 후 mst 구성





### 1249. [S/W 문제해결 응용] 4일차 - 보급로

- 2차원 버전의 다익스트라, bfs 변형으로 풀이





### 그래프 정리

- dfs, bfs - 빠짐없이 한번씩 접근은 반복이 쉬운편
- 백트래킹을 통한 문제 접근은 dfs, 재귀를 통한 접근이 쉬운편
- 시작점이 여러개 - bfs
- 가능한 모든 경로 수 - dfs 재귀 (visited 열고 풀고)
- 중복 가능, 중복 불가능한 bfs, dfs 문제
- 나중에 dp, 확률과 통계 문제 까지 접근?