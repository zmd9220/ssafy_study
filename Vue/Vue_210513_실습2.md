# Vue_210513_실습2



## 오전

- 홈워크 복습



### Vuex를 통해 todo앱 구현 (vuex 복습) - workshop 4 & 5

- 초기 vud add vuex 시 커밋하고 진행하라고 추천 (코드가 변경되는 부분이 있기 때문에)

- jsconfig.json을 만들어 자동완성 기능을 지원하도록 하기

  - [jsconfig.json Reference (visualstudio.com)](https://code.visualstudio.com/docs/languages/jsconfig#_using-webpack-aliases)
  - vue 자체는 src폴더를 @라고 세팅이 되어있지만, vscode 편집기에서는 @가 src 폴더라는 의미인지를 알지 못한다. 그래서 jsconfig.json으로 @가 src 폴더임을 vscode에 알려줌
  - 세팅 한 이후에 ctrl + shift + p (명령 팔레트) reload window
  - jsconfig.json을 vetur가 인식해서 vscode 상에서 script 부분에 자동완성 가능하도록 한다.

- v-for 사용시 key는 반드시 고유 값이어야함

  - 완료목록 미완목록 분리했다가 키 중복돼서 에러났습니다..

- 실제 서버에서 가져올 때는 pk값이 존재해서 v-for 등에 사용할 때 key 값을 사용 가능한데, 현재 프론트엔드 상에서는 pk가 따로 없어서 있다고 가정하고 개발하도록 해야함

  - lodash에서 랜덤한 해쉬값을 생성해주는 기능이 있는데 임시로 이것을 key값으로 사용할 수 있다.
  - 이번에는 타임스탬프를 사용해서 pk값을 해보기

- store에서 정의를 해놓고 (index.js) 사용시 `$store` 로 사용

- store의 데이터를 접근하기 위한 방법

  - 직접 template에서 $store.state 로 직접 접근

    - `v-for="(todo, index) in $store.state.todoList"`

  - computed에서 속성 반환 값에 $store.state로 접근

    - ```js
        computed: {
          todoList: function () {
            return this.$store.state.todoList
          }
      ```

  - vuex 에서 속성 부분만 import 하여 사용

    - ```js
      import { mapState } from 'vuex' 
        computed: {
          ...mapState(['todoList']),
        }
      ```



- v-for문을 잘 작성하는 것이 중요
  - 항상 데이터를 보낼 곳에서 받을 곳의 컴포넌트 문에 for 문을 작성 (컴포넌트 template)
  - v-for문 작성시 항상 key값을 넣어야함 + 고유값
  - 그리고 해당 데이터를 보낼 곳으로 데이터를 확실히 보내줘야함 :todo="todo"

```vue
    <TodoListItem 
      v-for="todo in todoList"
      :key="todo.createdAt"
      :todo="todo"
    />
```



- vuex에서 작성된 기능이나 데이터를 컴포넌트에서 작성된 변수나 함수처럼 사용하기위한 헬퍼 

  - mapActions, mapState 등이 있음

  - import를 해서 불러온 뒤, ...으로 접근

  - ```js
    import { mapActions } from 'vuex'
    methods: {
        ...mapActions(['addTodo']),
    ```

- 스페이스바를 통한 데이터 생성 방지 - trim 을 넣기



- 데이터 수정에 있어서 오류 가능성
- object spread operator

```js
const data = { name: 'jason', score: 100}
const data2 = { ...data, score: 80}
console.log(data2)
const data3 = { ...data }
data === data3 // false 나옴 deep copy가 됨
const shalData = data
data === shalData // true (shallow copy)
```



- 삭제 기능에 있어서 객체 주소에 의존하여 데이터를 처리하려고 하면 deep copy와 같은 일이 일어났을 때 삭제 객체와 state 객체의 주소가 달라서 제대로 된 처리가 되지 않음

```js
  methods: {
    onDeleteButtonClick: function () {
        // 이렇게 보낼 경우 에러
      this.$store.commit('DELETE_TODO', {this.todo})
    }
  }
}	
// 이 부분에서 충돌이 일어남 -> 별로 좋지 않은 삭제 코드 그래서 수정해야함
    DELETE_TODO: function (state, todoItem) {
      state.todoList = state.todoList.filter(todo => {
        return todo !== todoItem
      })
    }
```

- 장고와 마찬가지로 고유 키를 찾아서 삭제할 수 있도록 해야함

```js
  methods: {
    onDeleteButtonClick: function () {
      this.$store.commit('DELETE_TODO', this.todo.createdAt)
    }
  }
    DELETE_TODO: function (state, createdAt) {
      state.todoList = state.todoList.filter(todo => {
        return todo.createdAt !== createdAt
      })
    }
```

- 다시 정리하자면 객체를 넘겨받아 객체를 비교하게 될 경우 deep copy와 같은 상황이 발생했을 때, 객체 데이터는 같으나 객체 주소가 다르므로 !== 연산이 true가 되어 원하는 항목을 지우지 못하게 됨 그러므로 pk를 통한 접근을 권장

- 스플라이스?



- update의 경우에도 todo의 데이터를 수정해야할 경우 원하는 역할은 todoList의 해당 todo 부분을 수정해야 하는데, 데이터의 속성값이 많아 한번에 수정을 하고 그 값을 보내 수정하도록 보내려고 {...this.todo}로 해서 보낼려고 했을 때, todoList의 todo가 수정되는 것이 아닌 ...this.todo로 생성된 새로운 객체의 값만 변환된 채로 끝난다 => update가 실행은 되는데 todoList로의 갱신이 되지 않는다.
- 해결 방법? -  1. mapMutations 사용으로도 해결 가능, 2. todoItem의 고유 값을 찾아서 해당 객체의 부분을 수정

```js
    onTodoClick: function () {
      this.$store.commit('UPDATE_TODO', {...this.todo, todo.completed = !todo.comple)
    }
```



- 프로젝트가 커지면 commit을 직접 호출에서 사용할 일이 줄어들 것 ()