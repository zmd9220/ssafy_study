# Vue_210517_Vue+API서버



## 오전



### 지난 시간

- Vue Intro
  - Vuex
    - 상태 관리 패턴 라이브러리
  - Vuex Core Concepts
    - State, Actions, Mutations, Getters



### 서버 & 클라이언트



#### Server

- 클라이언트에게 '정보', '서비스'를 제공하는 컴퓨터 시스템
- 정보 & 서비스
  - Django를 통해 응답한 template
  - DRF를 통해 응답한 JSON



#### Client

- 서버에게 그 서버가 맞는(서버가 제공하는) **서비스를 요청**하고
- 서비스 요청을 위해 필요한 인자를 **서버가 원하는 방식에 맞게 제공**하며
- 서버로부터 반환되는 응답을 **사용자에게 적절한 방식으로 표현**하는 기능을 가진 시스템



#### 정리

- 서버는 정보 제공
  - DB와 통신하며 데이터를 CRUD
  - 요청을 보낸 Client에게 이러한 정보를 응답
- Client는 정보 요청 & 표현
  - 서버에게 정보(데이터) 요청
  - 응답 받은 정보를 잘 가공하여 화면에 보여줌



### CORS



#### Same-origin policy (SOP)

- 동일 출처 정책
- 특정 출처(origin)에서 불러온 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용 하는 것을 제한하는 보안 방식
- 잠재적으로 해로울 수 있는 문서를 분리함으로써 공격받을 수 있는 경로를 줄임
- 정의
  - 두 URL의 Protocol, Port, Host 가 모두 같아야 동일한 출처



#### Cross-Origin Resource Sharing (CORS)

- 교차 출처 리소스(자원) 공유
- **추가 HTTP header를 사용**하여, 특정 출처에서 실행중인 웹 애플리케이션이 **다른 출처의 자원에 접근 할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제**
- 리소스가 자신의 출처(Domain, Protocol, Port)와 다를 때 교차 출처 HTTP 요청을 실행
- 보안 상의 이유로 브라우저는 교차 출처 HTTP 요청을 제한 (SOP)
  - 예를 들어 XMLHttpRequest는 SOP를 따름
- 다른 출처의 리소스를 불러오려면 그 출처에서 **올바른 CORS header를 포함한 응답을 반환**해야함



#### CORS Policy

- 교차 출처 리소스(자원) 공유 정책
- 다른 출처(origin)에서 온 리소스를 공유하는 것에 대한 정책
- SOP와 반대



#### 교차 출처 접근 허용하기

- CORS를 사용해 교차 출처 접근 허용
- CORS는 HTTP의 일부로, 어떤 호스트에서 자신의 컨텐츠를 불러갈 수 있는지 **서버에 지정할 수 있는 방법**



#### Why CORS?

1. 브라우저 & 웹 어플리케이션 보호
   - 악의적인 사이트의 데이터를 가져오지 않도록 사전 차단
   - 응답으로 받는 자원에 대한 최소한의 검증
   - 서버는 정상적으로 응답하지만 브라우저에서 차단
2. 서버의 자원 관리
   - 누가 해당 리소스에 접근 할 수 있는지 관리 가능



#### How CORS?

- CORS 표준에 의해 추가된 **HTTP Header**를 통해 이를 통제
- CORS HTTP 응답 헤더 예시
  - Access-Control-Allow-Origin - 오늘 사용할 것
  - Access-Control-Allow-Credentials
  - Access-Control-Allow-Headers
  - Access-Control-Allow-Methods



#### Access-Control-Allow-Origin 응답 헤더

- 이 응답이 주어진 출처(origin)으로 부터 요청 코드와 공유 될 수 있는 지를 나타냄
- 예시
  - Access-Control-Allow-Origin: *
  - 브라우저 리소스에 접근하는 임의의 origin으로 부터 요청을 허용한다고 알리는 응답에 포함
  - '*'는 모든 도메인에서 접근할 수 있음을 의미
  - '*'외에 특정 origin 하나를 명시 할 수 있음





## 오후 웹코칭



#### 서버 클라이언트 복습

- 기존은 서버와 클라이언트를 한 곳에서 모두 다뤘음(장고)
- 자바스크립트를 배우고 나서 동적 클라이언트를 배움 (돔 조작)
- 효율적인 개발을 위해 vue, react 등이 도입 (우리는 vue 사용)
- 서버 (데이터 + 서비스 제공) - 처음에는 서버를 통해 템플릿 페이지까지 보냈지만 현재는 API 서버 사용 (데이터 요구에 맞게 가공하여 JSON으로 보냄)
- 클라이언트(서버에 데이터 요청, 사용자에게 적절히 표현) - 서버에 맞는 요청 제공



#### CORS 복습

- 서로 다른 리소스에 대해서 공유를 할지 말지 결정
- CSRF_TOKEN이 생긴 것과 같이 가짜 요청으로 인해 서버가 공격 받을 수 있음 (CORS를 자유롭게 풀어두면)
- SOP - 같은 오리진만 데이터 제공
- 기존적으로 브라우저는 SOP로 되어있는 이유는 CSRF_TOKEN, POST가 생겨난 이유와 유사함 (가짜 앱을 통한 해킹 및 공격을 막기 위해)
- 가짜 앱과 같은 곳에 (내가 신뢰하지 않는 곳에 대해) 데이터를 제공하지 않겠다 CORS - 똑같이 만들지 못하도록

- 똑같이 api 요청을 보냈음에도 vive.naver (아는 곳) 에서는 응답을 하고 모르는 곳 (내 로컬 컴퓨터) 에서는 거부를 보냄
- 오리진 여부는 프로토콜, 호스트, 포트까지 같아야함 (http - 프로토콜, localhost - 호스트, :3000 - 포트) 뒤의 패스는 달라도 됨 (서브 도메인만 달라도 다른 것 vive.naver != api.naver)
- CORS - 브라우저(+웹 어플리케이션) 보호 (브라우저 입장에선 내가 모르는 곳에서 데이터를 함부로 가져오지 않도록, 어플리케이션 입장에선 자신의 앱을 베껴서 만든 앱으로 사용자 해킹 공격 등을 방지하기 위해)
  - 최소한의 방어막
- 이러한 설정은 서버측에서 지정하는데 우리는 drf 기반으로 진행되므로 장고의 라이브러리를 이용하여 설정할 것
- JSON.parse
- 장고용 cors 라이브러리
- https://github.com/adamchainz/django-cors-headers 
- 미들웨어 - 뷰 컨트롤러로 가기 전에, 먼저 적절한 요청인지 확인함 장고에서 위에서 부터 아래로 적은 순서대로 확인을 함 (검증, 데이터 전처리, 뷰에서 사용할 변수 만들기 등등) - cors는 가능한 상단에 위치하도록 둘 것을 제작자가 권장
- CORS 페이지는 정규표현식으로도 작성 가능
- 일단 현재는 특정 웹페이지가 없으므로 (연습용) 모든 요청에 대해 허용하도록 CORS_ALLOW_ALL_ORIGINS = True

- CORS는 브라우저에서 제공하는 규칙이지 컴퓨터 상에서 직접 요청하거나 포스트맨과 같은 프로그램으로 요청하면 바로 데이터를 받을 순 있음 (응답 ok)





## 오후 라이브

- jwt 인증 방식을 배움





## 오후 웹코칭 2

- jwt(토큰)에 대한 개념 이해가 제일 중요한 포인트

- 과거 세션 쿠키 방식도 사용되지만 최근에 토큰을 통한 인증 방식도 많이 사용되는 인증 방법 중 하나
- 세션 쿠키 방식의 문제점 - 로그인 시 db에 접근해서 찾아야함 + 발행한 세션을 따로 db로 관리해야됨 (저장공간 차지)
- 토큰 방식 
  - 서버에서 비밀 키로 토큰을 작성하여 클라이언트에게 제공 (db에 저장 x, 조회 x)
  - 클라이언트는 로컬 저장소나 쿠키에 토큰을 저장, 요청할 때 토큰을 같이 보냄
  - 서버에선 인증 함수를 통해 비밀 키로 실행한 결과가 true로 나온다 -> 인증된 유저 확인
- 토큰 방식에서 취약점?
  - 토큰을 중간에 가로챌 수 있으면 인증된 유저로써 내부에 접근 가능해짐
- 그럼에도 사용하는 이유 - 토큰이 뺏길 일이 없기 때문

- 계정 해킹 당하는 것들은 api 서버에 정보가 있어서 그런가요? - 정보가 저장된 서버가 털려서 그런 것 클라이언트에서는 털일 일이 거의 없다.
- 해킹 이슈(스팀? otp?)

- api 서버에서 헤더에 토큰을 담아 같이 사용함



#### JWT 구조

- 헤더 - 토큰 타입 및 알고리즘 타입 정의
- 페이로드 - 요청을 보내는 사람의 기본 정보 - 중요한 정보는 들어가면 안됨 (누구나 열어서 해석 가능함, JSON 형태)
- 누가 어떠한 시크릿 키를 보냈는지에 대한 것이 암호화 (핵심 인증 기능) - 서버에서는 암호 키를 주기적으로 바꾸던가 관리를 빡빡하게 함 (핵심 키 이므로)
- 클라이언트는 로컬 저장소에 저장하고 요청시에만 같이 담아서 보낸다. 로그아웃하면 토큰을 삭제한다. - 토큰이 있다 = 로그인, 토큰이 없다 = 로그아웃

- 서버는 토큰 생성 요청에 응답한다. 모든 요청에 대해 토큰 여부를 판단한다.
- jwt는 두 가지 토큰이 있다.
  - Access - 지금까지 말했던 인증 관련 토큰 - 토큰의 유지 시간이 매우 짧음 
  - Refresh - Access 발행시 함께 넘겨주는 토큰으로 보통 2주 정도로 기간이 긴편, 리프레시 서버에서 해당 토큰을 확인하면 Access 토큰을 다시 재발행 해줌 리프레시 토큰이 유지되는 동안에는 로그인과 같은 재인증이 필요 X
  - 한 번 로그인 하면 계속 로그아웃되지 않는 사이트 -> 접속할 때 마다 새롭게 갱신된 토큰을 건네줌
- 쿠키와 로컬저장소 어디다 저장이 좋을까? - 둘 다 나눠서 저장하면 좋지 않을까?

- django rest framework jwt 실습
- https://jpadilla.github.io/django-rest-framework-jwt/
- 라이브러리 설치, settings.py에 등록, 유효기간 증가 (연습용이므로 기존 5분으론 짧음)

- jwt 인증에 대해 전역으로 사용할거면 settings.py에 등록을 하고, 개별적으로 사용할 거면 필요한 부분에만 데코레이터로 추가

- curl 터미널에서 요청을 보내는 방법 (커맨드)
- 구현은 간단한 편, 클라이언트에서 자유롭게 만들어서 인증시스템을 구축된 것 처럼 보이게 만들어 주는 것을 내일 연습해볼 것

