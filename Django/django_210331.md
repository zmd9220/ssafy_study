[toc]

# Django_210331 





## Many to many relationship

- 다대다 관계에 대해 배움
- 수업은 의사와 환자의 예약 시스템을 기준으로 진행했음
- 실제 예시로 학생과 수강신청, 유저와 좋아요, 참여한 방과 유저 등등 다양하다.

---





### 1. 1:N 관계의 한계

- 환자 모델에 의사를 외래키로 넣고 진행 했을 때
- 기존 환자 예약 시스템에서 환자가 의사를 변경하려고 할 때 변경이 불가
- 또는 환자가 여러 명의 의사에 예약을 하는 경우에도 하나 밖에 받지 못함



___



### 2. 중개모델

- 의사와 환자의 id를 외래키로 받는 중개 모델인 Reservation을 생성 (1:N 관계를 2개)
- 중개 모델로 했을 때 의사나 환자가 예약을 확인하려면 Reservation 모델에서 역참조를 통해 가져와야 함(1 측에서 N측의 데이터를 가져오려면)
- 1:N 한계를 개선 - 이러한 관계를 M:N 관계라고 함.

``` shell
In [1]: doctor1 = Doctor.objects.create(name='justin')

In [2]: patient1 = Patient.objects.create(name='tony')

In [3]: doctor2 = Doctor.objects.create(name='eric')

In [4]: patient2 = Patient.objects.create(name='harry')

In [5]: doctor1.reservation_set.all()
    
Reservation.objects.create(doctor=doctor1, patient=patient1)    
patient1.reservation_set.all()
```



___



### 3. 장고에서의 M:N 지원

- 장고에서는 M:N 관계를 지원하기 위해 many to many field를 지원
- many to many field는 복수형으로 작성을 추천
- 위에 만들었던 중개모델을 장고가 알아서 생성을 해줌 hospitals_patient_doctors

``` shell
In [1]: doctor1 = Doctor.objects.create(name='justin')

In [2]: patient1 = Patient.objects.create(name='tony')

In [3]: doctor2 = Doctor.objects.create(name='eric')

In [4]: patient2 = Patient.objects.create(name='harry')

```



___



### 4. 장고 mtom field 에서의 서로 간의 관계 연결

- 이러한 상황에서 중개모델과의 연결은 어떻게 할까? - 참조와 역참조로 서로를 직접 연결하면 됨.
- 다만 물리적으로 mtom field 가 존재하는 곳(환자)이 참조, 대상이 되는 곳(의사)은 역참조를 해야함

``` shell
In [5]: patient1.doctors.add(doctor1)

In [6]: doctor1.patient_set.all() - 역참조
Out[6]: <QuerySet [<Patient: 1번 환자 tony>]>

In [7]: patient1.doctors.all() - 참조
Out[7]: <QuerySet [<Doctor: 1번 의사 justin>]>

In [8]: doctor1.patient_set.add(patient2)
    
In [9]: doctor1.patient_set.remove(patient1)

In [10]: patient2.doctors.remove(doctor1)
```

- 장고 mtom field 가 중개모델을 만들어 주니까 중개 모델을 생성할 필요가 없지 않을까? - 기본적인 기능만 사용하려면 충분하지만 추가적인 요소(시간, 위치 등)가 더 필요한 경우 별도의 중개 모델을 생성해 관리해야함
- 좀 더 상호간에 규칙성이 있게 보이려면 related_name='patients' 로 하면 patient_set 보다 관계가 좀 더 명확하게 보일 수도? - 개인적 취향

```shell
In [1]: doctor1 = Doctor.objects.get(pk=1)

In [2]: doctor1
Out[2]: <Doctor: 1번 의사 justin>

In [3]: doctor1.patient_set.all()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-3-e81b89c43a95> in <module>
----> 1 doctor1.patient_set.all()

AttributeError: 'Doctor' object has no attribute 'patient_set'

In [4]: doctor1.patients.all()
Out[4]: <QuerySet [<Patient: 1번 환자 tony>, <Patient: 2번 환자 harry>]>
```

---



### 정리

1. many to many field로 인해 데이터 원본이 변경되진 않는다.
2. 1:N 의 경우 N이 1에 종속되어 있다.
3. 하지만 M:N은 서로가 서로에게 종속이라고 볼 수 있음 (사용하는 상황에 따라)

---



### 이론 ppt



#### Related manager 개념

- 1:N 또는 M:N 관련 컨텍스트에서 사용되는 매니저 
- 사용되는 함수는 1:N 이냐 M:N 이냐에 따라 사용 결과가 달라짐(대상이나 등등)
- 타겟 - 참조 되는 모델, 소스 - 참조 하는 모델
- 1:N 에서는 타겟 모델 객체만 사용 가능
- M:N 에서는 서로 사용 가능
- 대표적인 메소드 - add() - 서로 연결, remove() - 연결 해제



#### many to many field's arguments

- related_name - 역참조시에 부를 이름 변경 (기본 클래스명_set)
- symmetrical - 대칭적 소스가 타겟을 참조하면 타겟도 소스를 참조하게 됨 - 대칭을 원하지 않으면 False
- through - 기본 제공하는 중개모델 외에 추가 데이터를 관리하고 싶을 때 직접 중개모델을 생성하는 기능

---

<br>



## M:N 관계 실습 2 - 좋아요, 팔로우 기능

- 08_django_model_relationship 프로젝트에서 진행
- 좋아요, 팔로우 기능을 실습해보며 M:N 관계에 대해 이해

---



### 좋아요 - like_users

- 좋아요의 경우 한 유저가 여러 게시글에 좋아요를 누를 수 있고, 한 게시글에는 여러 유저의 좋아요가 모인다. 즉 M:N 관계로 진행이 된다.
- 여기서 mtom 필드를 작성하고 makemigrations 하려고하면 에러가 나온다 - user를 사용하는 것이 외래키, mtom 2개가 있으므로 역참조시에 article_set 의 이름이 겹치는 문제

```
ERRORS:
articles.Article.like_users: (fields.E304) Reverse accessor for 'Article.like_users' clashes with reverse accessor for 'Article.user'.
        HINT: Add or change a related_name argument to the definition for 'Article.like_users' or 'Article.user'.
articles.Article.user: (fields.E304) Reverse accessor for 'Article.user' clashes with reverse
accessor for 'Article.like_users'.
        HINT: Add or change a related_name argument to the definition for 'Article.user' or 'Article.like_users'.
```

- 그러므로 해결방법은 user 나 like_users 중에 하나를 related_name 으로 Related manager 명을 변경 - 기본적으로 mtom 쪽을 권장

 ```python
like_users = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name='like_articles')
 ```

- 어느 앱에서 진행할 거냐? - 게시글 모델에서 작성했기도 했고, 게시글 관련 좋아요 기능이므로 게시글 앱이 조금 더 나을것이라 생각 
- url 추가

```python
path('<int:article_pk>/likes/', views.likes, name='likes'),
```

- views.py 에서 like 기능 구현

```python
@require_POST
def likes(request, article_pk):
    article = get_object_or_404(Article, pk=article_pk)

    # 현재 요청 들어온 유저가 좋아요를 누른 유저 리스트 중에 존재할 경우
    if request.user in article.like_users.all():
        # 좋아요 누름
        article.like_users.add(request.user)
    else:
        # 좋아요 취소
        article.like_users.remove(request.user)

    return redirect('articles:index')
```

- index.html 에 좋아요 버튼 추가

```django
    <div>
      <form action="{% url 'articles:likes' article.pk %}" method="post">
        {% csrf_token %}
        {% if request.user in article.like_users.all %}
          <button>좋아요 취소</button>
        {% else %}
          <button>좋아요</button>
        {% endif %}
      </form>
    </div>
```



