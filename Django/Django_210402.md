# Django_210402



## 협업을 위한 Git 사용법

### 1. Git 팁들

- 기능별로 구현이 완료 되었을 때 하나의 묶음으로 커밋을 하는게 데이터 및 개발 흐름을 보기 편하므로 추천
- 깃은 개발시 항상 로컬 브랜치가 어디인지 확인해야 함.  - pull push 작업이 어느 브랜치를 기준으로 일어나는지
- gitlab 과 github 는 대부분 비슷하지만 단어가 조금씩 다르다. ex) merge request = pull request



___



### 2. Git을 통한 협업 방법

- 양쪽의 컴퓨터에서 하나의 깃 프로젝트를 공유해서 각자 맡은 역할을 개발할 때, 어떻게 합치고 관리를 할까?
- 일단 서로 branch를 만들어서 각각의 역할에 따라 개발 (나누는 기준은 개발 상황, 환경에 따라 다를 것)
- 예시 상황은 A는 like, follow 를 개발 했다고 하고 change 라는 branch, B는 signup, login 을 개발 했다고 하고 branch는 aclass 라고하자.
- 일단 한 쪽은 별 무리 없이 merge가 가능할 것이다. (마스터는 비어있는 상태고 완료된 브랜치에서 올리는데 지장이 있는 상황이 아니기 때문) -  우리는 A가 change를 먼저 합쳤다고 가정함.
- 이러한 상황에서 aclass 브랜치를 가진 B 개발자의 로컬 마스터 상황과,  git 저장소의 마스터 상황이 다름(git은 현재 change 까지 합쳐진 상태)
- aclass 에서 merge를 시도하면 change 의 개발 변경사항과 aclass의 개발 사항이 충돌이 일어남.
- 이러한 충돌을 해결하는 방법은 git 원격 저장소에서 직접 해결하는 방법과 로컬에서 해결하는 방법이 있는데, 실제 코드를 실행해보고 로직적인 문제가 있는지 확인해야 하므로 가능한 로컬에서 진행하는 것을 추천 
- B의  로컬 마스터에 pull master로 현재 최신 변경 사항을 가져오기

```bash
$ git switch master
$ git pull origin master
```

- 이후에 B의 로컬에서 merge 를 통해 적절히 처리를 하기 - 나오는 변경 사항은 여러 확인을 하고 변경 완료 (우리는 A, B의 기능을 모두 합쳤다고 가정)

```bash
$ git merge aclass
```

- 처리를 통해 병합을 완료하면 변경사항을 다시 git 원격 저장소로 push

``` bash
$ git push origin master
```

- 이렇게 하면 원격 저장소의 merge request도 merged 된 상태로 저장되어 있음 - 완료
- 현 상황에서 원격 저장소와 B는 서로 싱크가 맞는 상태인데, A의 로컬은 싱크가 맞지 않으므로 추후 다시 충돌이 일어날 것, 방법은 최신 버전을 pull 한 뒤에 작업을 시작하던가, 아니면 B 처럼 해결하던가 둘 중의 하나의 방법으로 진행하면 됨 
- 브랜치 제거는 gitlab 페이지에서만 할 수 있나요? 각각의 로컬과 git 저장소의 브랜치는 서로 다름, 로컬의 브랜치는 로컬에서 제거해야함

___



### 3. Contribute

- 깃 저장소를 보고 있는 동안 에러 사항이나 변경하면 좋을 부분이 발견 되었을 때 해당 개발자에게 도움을 주는 방법 - Contribute (해당 프로젝트에 기여)
  1. 개발자에게 어떤 부분을 어떻게 했으면 좋겠다 알려주기 - 간접 참여
  2. 나한테 해당 부분에 대한 개발 권한을 부여해달라고 한 뒤, 직접 수정해주기 - 직접 참여

#### 1. 개발자에게 알려주기 - Issue

- 이슈라는 게시판(일종의 자유게시판과 유사)에 내가 ~~ 부분에 문제가 있다고 적을 수 있음
- ` 태그 ` 를 통해 알려줘도 되고, 옆에 체인키를 눌러 원하는 위치 링크 생성후 알려주는 것도 가능
- 코드의 경우 쉬프트와 체인 버튼을 이용하여 ~~줄 부터 ~~줄 까지의 링크 생성도 가능 - 해당 줄의 수정을 요구 할 수 있음

#### 2. 내가 직접 수정하기 - Fork

- fork 명령어로 git 저장소 내 원하는 위치에 해당 레포지토리 복사가능
- 복사 후 로컬 등을 통해 원하는 대로 수정
- 이후 merge request를 하는데 원본 레포지토리에 해당 fork 된 레포지토리의 변경 사항을 병합 요청
- 이후 해당 레포지토리 관리자가 확인 후 적절한 변경이라도 판단 되면 반영
- Fork가 된 상태에만 repo끼리 merge가 되는건가요? - 꼭 fork로 가져와야만 히스토리까지 반영되므로 같은 레포지토리라고 판단됨 - 개인이 가져와서 복사해서 생성한다고 같은 레포지토리로 판단하지 않음



___



## 장고 기존에 배운 것을 기반으로 한 추가 기능

- 명세에 나와있는 것만 개발을 끝내는 것보다 추가적인 기능을 구현하던가 더 예쁘게 다듬던가 하는것이 개발실력 향상에 도움이됨 ex) 80까지 개발하세요 라고 하면 100~120까지 개발하는 것이 좋음
- crud 를 활용하여 추가적인 개발을하고자 해도 막상 생각이 나질 않음
- 이럴 때 좋은 방법은 특정 웹서비스 사이트를 클론으로 만들어 보는것 - crud를 활용하여 사이트마다 다양한 구현법을 배울 수 있음



### 1. allauth 를 통한 소셜로그인 가볍게 구현해보기 

- https://django-allauth.readthedocs.io/en/latest/installation.html

- 중간 질문 - 마이그레이션은 모델에 변화가 있을 때 한다고 배웠는데, settings,py에 변화가 있을 때에도 해주어야 하나요? allauth 내의 3개의 앱을 추가했음 (account와 social login 등) 이 앱이 사용하는 모델에 대한 테이블 생성을 위해 migrate가 필요

- 장고를 통해 앱 생성후 url을 보면 겹치는 페이지가 존재하는데 어차피 장고는 겹치면 위의 것만 사용함 그러므로 중복에 대한 문제는 걱정 X (두 기능 모두 필요하면 url을 수정해주기)



### 2. 장고 내부 페이지네이션 기능

- https://docs.djangoproject.com/en/3.1/topics/pagination/
- 



- https://pypi.org/project/django-bootstrap-pagination/





## SQL 총정리

### db 시험 준비 요약

- 장고 프로젝트 내 기본 문서들 읽어보기 (markdown) - 다음 주 시험은 sql 마크다운 중점으로
- orm, sql 두 개의 db를 기반으로 이해하기
- DDL, DML 중점적으로 (DCL은 안써봄)
- sqlite . 명령어는 넘어가고 (우리는 sqlite 를 수단으로 쓰는거지 배우고자 하는 것은 sql, orm임)

#### DDL

- 테이블 생성(CREATE)

- contraint field 에러 등 not null 조건



#### DML 데이터 조작 + 이것을 ORM으로 바꾼다면 어떻게 바꿀수 있지?

- INSERT (추가)
- SELECT (조회) - 조건을 만드는법 잘 보기 
- DELETE (삭제)
- UPDATE (수정)
- READ - WHERE 를 통한 심화 (특정 조건)



#### 심화 sql문

- expressions - count, max, min, avg
- like - _ , % 
- 정렬 - order_by (asc - 오름, desc - 내림)
- group by - orm의 annotate와 대응
- alter - 테이블 변경



#### 장고의 모델들

- 1:N - foreignkey 속성, 참조 역참조 관계, 
- M:N  -mtom 속성, 참조 역참조 관계
- 워크샵, 홈워크 복습



#### 중요한 순서

1. sql <-> orm의 변환 및 문법
2. 1:N 관계 models.py 중점으로
3. M:N 관계 